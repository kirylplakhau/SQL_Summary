	*** Индекс — объект базы данных, создаваемый с целью повышения производительности поиска данных. 
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, 
и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. 
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. 
Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск.

** По порядку сортировки
 * Упорядоченные  — индексы, в которых элементы поля(столбца) упорядочены.
Возрастающие
Убывающие
 * Неупорядоченные — индексы, в которых элементы неупорядочены.

** По источнику данных
 * Индексы по представлению (view).
 * Индексы по выражениям — например в PostgreSQL.

** По воздействию на источник данных
 * Некластерный индекс — наиболее типичные представители семейства индексов. В отличие от кластерных, они не перестраивают физическую структуру таблицы, а лишь организуют ссылки на соответствующие строки. 
Для идентификации нужной строки в таблице некластерный индекс организует специальные указатели, включающие в себя: 
информацию об идентификационном номере файла, в котором хранится строка; идентификационный номер страницы соответствующих данных; 
номер искомой строки на соответствующей странице; содержимое столбца.
 * Кластерный индекс — Принципиальным отличием кластерного индекса от индексов других типов является то, что при его определении в таблице физическое расположение данных перестраивается в соответствии со структурой индекса. 
Логическая структура таблицы в этом случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены, например по алфавиту. 
Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. 
Увеличение производительности особенно заметно при работе с последовательными данными.

** По структуре
 * B-Tree. Семейство B-Tree индексов — это наиболее часто используемый тип индексов, организованных как сбалансированное дерево, упорядоченных ключей. 
Они поддерживаются практически всеми СУБД как реляционными, так нереляционными, и практически для всех типов данных.
Единственное, что, пожалуй, следует здесь отметить, это то, что данный тип индекса оптимален для множества с хорошим распределением значений и высокой мощностью(cardinality-количество уникальных значений).
 * Spatial grid. Spatial grid(пространственная сетка) index – это древовидная структура, подобная B-дереву, но используется для организации доступа к пространственным(Spatial) данным, 
то есть для индексации многомерной информации, такой, например, как географические данные с двумерными координатами(широтой и долготой). 
В этой структуре узлами дерева выступают ячейки пространства. Например, для двухмерного пространства: сначала вся родительская площадь будет разбита на сетку строго определенного разрешения, 
затем каждая ячейка сетки, в которой количество объектов превышает установленный максимум объектов в ячейке, будет разбита на подсетку следующего уровня. 
Этот процесс будет продолжаться до тех пор, пока не будет достигнут максимум вложенности (если установлен), или пока все не будет разделено до ячеек, не превышающих максимум объектов.
 * Quadtree – это подвид Grid-based Spatial index, в котором в родительской ячейке всегда 4 потомка и разрешение сетки варьируется в зависимости от характера или сложности данных.
 * R-Tree (Regions Tree) – это тоже древовидная структура данных подобная Spatial Grid, предложенная в 1984 году Антонином Гуттманом. Эта структура данных тоже разбивает пространство на множество иерархически вложенных ячеек, 
но которые, в отличие от Spatial Grid, не обязаны полностью покрывать родительскую ячейку и могут пересекаться.
Для расщепления переполненных вершин могут применяться различные алгоритмы, что порождает деление R-деревьев на подтипы: с квадратичной и линейной сложностью(Гуттман, конечно, описал и с экспоненциальной сложностью — Exhaustive Search, 
но он, естественно, нигде не используется).
Квадратичный подтип заключается в разбиении на два прямоугольника с минимальной площадью, покрывающие все объекты. Линейный – в разбиении по максимальной удаленности.

** По количественному составу
 * Простой индекс (индекс с одним ключом) — строится по одному полю.
 * Составной (многоключевой, композитный) индекс — строится по нескольким полям. Важен порядок следования полей (например в MongoDB).
 * Индекс с включенными столбцами — Некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов еще и неключевые.
 * Главный индекс (индекс по первичному ключу) — это тот индексный ключ, под управлением которого в данный момент находится таблица. Таблица не может быть отсортирована по нескольким индексным ключам одновременно. 
Хотя, если одна и та же таблица открыта одновременно в нескольких рабочих областях, то у каждой копии таблицы может быть назначен свой главный индекс.

** По характеристике содержимого
 * Уникальный индекс — состоит из множества уникальных значений поля.
Плотный индекс (NoSQL) — индекс, при котором, каждом документе в индексируемой коллекции соответствует запись в индексе, даже если в документе нет индексируемого поля.
 * Разреженный индекс (NoSQL) — тот, в котором представлены только те документы, для которых индексируемый ключ имеет какое-то определённое значение (существует).
 * Пространственный индекс — оптимизирован для описания географического местоположения. Представляет из себя многоключевой индекс состоящий из широты и долготы.
 * Составной пространственный индекс — индекс, включающий в себя кроме широты и долготы ещё какие-либо мета-данные (например теги). Но географические координаты должны стоять на первом месте.
 * Полнотекстовый (инвертированный) индекс — словарь, в котором перечислены все слова и указано, в каких местах они встречаются. 
При наличии такого индекса достаточно осуществить поиск нужных слов в нём и тогда сразу же будет получен список документов, в которых они встречаются.
 * Хэш-индексы — предполагают хранение не самих значений, а их хэшей, благодаря чему уменьшается размер(а, соответственно, и увеличивается скорость их обработки) индексов из больших полей. 
Таким образом, при запросах с использованием HASH-индексов, сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей.
Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». 
Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
 * Битовый индекс (bitmap index) — метод битовых индексов заключается в создании отдельных битовых карт (последовательность 0 и 1) для каждого возможного значения столбца, 
где каждому биту соответствует строка с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.
 * Обратный индекс (reverse index) — это тоже B-tree индекс но с реверсированным ключом, используемый в основном для монотонно возрастающих значений(например, автоинкрементный идентификатор) в OLTP системах 
с целью снятия конкуренции за последний листовой блок индекса, т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. Он не может использоваться для диапазонного поиска.
 * Функциональный (function-based) индекс (индекс по вычисляемому полю) — индекс, ключи которого хранят результат пользовательских функций. 
Функциональные индексы часто строятся для полей, значения которых проходят предварительную обработку перед сравнением в команде SQL. 
Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. Создание функционального индекса с функцией UPPER улучшает эффективность таких сравнений. 
Кроме того, функциональный индекс может помочь реализовать любой другой отсутствующий тип индексов данной СУБД(кроме, пожалуй, битового индекса, например, Hash для Oracle).
 * Первичный индекс — уникальный индекс по полю первичного ключа.
 * Вторичный индекс — индекс по другим полям (кроме поля первичного ключа).
 * XML-индекс — вырезанное материализованное представление больших двоичных XML-объектов (BLOB) в столбце с типом данных xml.

** По механизму обновления
 * Полностью перестраиваемый — при добавлении элемента заново перестраивается весь индекс.
 * Пополняемый (балансируемый) — при добавлении элементов индекс перестраивается частично (например одна из ветви) и периодически балансируется.

** По покрытию индексируемого содержимого
 * Полностью покрывающий (полный) индекс — покрывает всё содержимое индексируемого объекта.
 * Частичный (partial) индекс — это индекс, построенный на части таблицы, удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.
 * Инкрементный (Delta) индекс — индексируется малая часть данных(дельта), как правило, по истечении определённого времени. Используется при интенсивной записи. Например, полный индекс перестраивается раз в сутки, 
а дельта-индекс строится каждый час. По сути это частичный индекс по временной метке.
 * Real-time индекс — особый вид delta индекса в Sphinx, характеризующийся высокой скоростью построения. Предназначен для часто-меняющихся данных.

** Индексы в кластерных системах
 * Глобальный индекс — индекс по всему содержимому всех shard’ов (секций).
 * Сегментный индекс — глобальный индекс по полю-сегментируемому ключу (shard key). Используется для быстрого определения сегмента(shard’а), на котором хранятся данные в процессе маршрутизации запроса в кластере БД.
 * Локальный индекс —  индекс по содержимому только одного shard’а.
https://use-the-index-luke.com/  - sql indexes book
